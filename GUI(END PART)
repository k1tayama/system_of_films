from typing import List, Dict, Optional
from abc import ABC, abstractmethod
from enum import Enum
import statistics
from dataclasses import dataclass

# БЛОК 1

class Genres(Enum):
    ACTION = "Action"
    ADVENTURE = "Adventure"
    COMEDY = "Comedy"
    SCI_FI = "Sci-Fi"
    DRAMA = "Drama"
    HORROR = "Horror"
    THRILLER = "Thriller"
    FANTASY = "Fantasy"
    ROMANCE = "Romance"
    MYSTERY = "Mystery"
    ANIMATION = "Animation"
    FAMILY = "Family"
    CRIME = "Crime"
    BIOGRAPHY = "Biography"
    HISTORY = "History"
    MUSICAL = "Musical"
    WESTERN = "Western"
    DOCUMENTARY = "Documentary"

class Film:
    def __init__(self, movie_id: int, title: str, genres: List[Genres], director: str, year: int, rating: float):
        self._id = movie_id
        self._title = title
        self._genres = genres
        self._director = director
        self._year = year
        self._rating = rating

    def __str__(self):
        return f"{self._title} ({self._year}) - рейтинг: {self._rating}"
    @property
    def movie_id(self):
        return self._id

    @property
    def title(self):
        return self._title

    @property
    def genres(self):
        return self._genres

    @property
    def director(self):
        return self._director

    @property
    def year(self):
        return self._year

    @property
    def rating(self):
        return self._rating

    @title.setter
    def title(self, value):
        if not value:
            raise ValueError("Поле не может быть пустым")
        value = value.strip()
        if not isinstance(value, str):
            raise TypeError("Название должно быть строкой")
        self._title = value

    @genres.setter
    def genres(self, value):
        if not isinstance(value, list):
            raise TypeError("genres должен быть списком")
        if not all(isinstance(g, Genres) for g in value):
            raise TypeError("Каждый элемент genres должен быть элементом перечисления Genres")
        if not value:
            raise ValueError("Поле не может быть пустым")
        self._genres = value

    @director.setter
    def director(self, value):
        if not value:
            raise ValueError("Поле не может быть пустым")
        if not isinstance(value, str):
            raise TypeError("Название должно быть строкой")
        self._director = value

    @year.setter
    def year(self, value):
        if not value:
            raise ValueError("Поле не может быть пустым")
        if not (1800 <= value <= 2100):
            raise ValueError("Год фильма должен быть в диапазоне 1800–2100")
        self._year = value

    @rating.setter
    def rating(self, value):
        if not (0 <= value <= 10):
            raise ValueError("Рейтинг должен быть от 0 до 10")
        self._rating = float(value)

class User:
    def __init__(self, user_id, user_name, watched_films=None, preferred_genres=None):
        self._id = user_id
        self._name = user_name
        if watched_films:
            self._watched_films = watched_films
        else:
            self._watched_films = {}
        if preferred_genres:
            self._preferred_genres = preferred_genres
        else:
            self._preferred_genres = []

    @property
    def user_id(self):
        return self._id

    @user_id.setter
    def user_id(self, value):
        if not isinstance(value, int):
            raise TypeError("user_id должен быть числом")
        if value <= 0:
            raise ValueError("user_id должен быть положительным")
        self._id = value

    @property
    def user_name(self):
        return self._name

    @user_name.setter
    def user_name(self, value):
        if not isinstance(value, str):
            raise TypeError("user_name должен быть строкой")
        value = value.strip()
        if not value:
            raise ValueError("user_name не может быть пустым")
        self._name = value

    @property
    def watched_films(self):
        return self._watched_films

    @watched_films.setter
    def watched_films(self, value):
        if not isinstance(value, dict):
            raise TypeError("watched_films должен быть словарём")
        self._watched_films = value

    @property
    def preferred_genres(self):
        return self._preferred_genres

    @preferred_genres.setter
    def preferred_genres(self, value):
        if not isinstance(value, list):
            raise TypeError("preferred_genres должен быть списком")
        self._preferred_genres = value

    def add_watched_film(self, film: Film, rating: float):
        self._watched_films[film] = rating

    def get_rating(self, film: Film):
        return self._watched_films.get(film, None)

    # Новый метод для получения названий предпочтительных жанров
    def get_preferred_genres_names(self):
        return [genre.value for genre in self._preferred_genres]

class DataManager:
    def __init__(self):
        self._films = {}
        self._users = {}

    def add_film(self, film: Film):
        if film._id in self._films:
            print(f"Фильм с ID {film._id} уже существует.")
        else:
            self._films[film._id] = film

    def add_user(self, user: User):
        if user._id in self._users:
            print(f"Пользователь с ID {user._id} уже существует")
        else:
            self._users[user._id] = user

    # Новый метод для получения пользователя по имени(Для регистрации)
    def get_user_by_name(self, user_name: str):
        for user in self._users.values():
            if user.user_name == user_name:
                return user
        return None

    def load_data(self):
        sample_films = [
            Film(1, "Inception", [Genres.ACTION, Genres.THRILLER], "Nolan", 2010, 8.8),
            Film(2, "Titanic", [Genres.DRAMA, Genres.ROMANCE], "Cameron", 1997, 7.8),
            Film(3, "The Lion King", [Genres.ANIMATION, Genres.FAMILY], "Allers", 1994, 8.5),
            Film(4, "Avengers: Endgame", [Genres.ACTION, Genres.ADVENTURE], "Russo", 2019, 8.4),
            Film(5, "Joker", [Genres.DRAMA, Genres.CRIME], "Phillips", 2019, 8.5),
            Film(6, "Frozen", [Genres.ANIMATION, Genres.FAMILY], "Buck", 2013, 7.5),
            Film(7, "Pulp Fiction", [Genres.CRIME, Genres.DRAMA], "Tarantino", 1994, 8.9),
            Film(8, "The Godfather", [Genres.CRIME, Genres.DRAMA], "Coppola", 1972, 9.2),
            Film(9, "The Dark Knight", [Genres.ACTION, Genres.THRILLER], "Nolan", 2008, 9.0),
            Film(10, "Forrest Gump", [Genres.DRAMA, Genres.ROMANCE], "Zemeckis", 1994, 8.8),
            Film(11, "The Matrix", [Genres.ACTION], "Wachowski", 1999, 8.7),
            Film(12, "Gladiator", [Genres.ACTION, Genres.DRAMA], "Scott", 2000, 8.5),
            Film(13, "La La Land", [Genres.DRAMA, Genres.MUSICAL], "Chazelle", 2016, 8.0),
            Film(14, "The Shawshank Redemption", [Genres.DRAMA, Genres.CRIME], "Darabont", 1994, 9.3),
            Film(15, "The Avengers", [Genres.ACTION, Genres.ADVENTURE], "Whedon", 2012, 8.0),
            Film(16, "Interstellar", [Genres.ADVENTURE, Genres.SCI_FI], "Nolan", 2014, 8.6),
            Film(17, "Parasite", [Genres.THRILLER, Genres.DRAMA], "Bong", 2019, 8.6),
            Film(18, "Spirited Away", [Genres.ANIMATION, Genres.FANTASY], "Miyazaki", 2001, 8.6),
            Film(19, "The Wolf of Wall Street", [Genres.COMEDY, Genres.DRAMA], "Scorsese", 2013, 8.2),
            Film(20, "Mad Max: Fury Road", [Genres.ACTION, Genres.ADVENTURE], "Miller", 2015, 8.1),
            Film(21, "Avatar", [Genres.ACTION, Genres.ADVENTURE, Genres.FANTASY], "Cameron", 2009, 7.8),
            Film(22, "The Social Network", [Genres.DRAMA, Genres.BIOGRAPHY], "Fincher", 2010, 7.7),
            Film(23, "Guardians of the Galaxy", [Genres.ACTION, Genres.ADVENTURE, Genres.COMEDY], "Gunn", 2014, 8.0),
            Film(24, "Coco", [Genres.ANIMATION, Genres.FAMILY, Genres.MUSICAL], "Unkrich", 2017, 8.4),
            Film(25, "Jumanji: Welcome to the Jungle", [Genres.ADVENTURE, Genres.COMEDY], "Johnson", 2017, 6.9),
            Film(26, "Black Panther", [Genres.ACTION, Genres.ADVENTURE], "Coogler", 2018, 7.3),
            Film(27, "Toy Story 3", [Genres.ANIMATION, Genres.FAMILY], "Lasseter", 2010, 8.3),
            Film(28, "Deadpool", [Genres.ACTION, Genres.COMEDY], "Reynolds", 2016, 8.0),
            Film(29, "Shrek", [Genres.ANIMATION, Genres.COMEDY, Genres.FAMILY], "Adamson", 2001, 7.9),
            Film(30, "Fight Club", [Genres.DRAMA, Genres.THRILLER], "Fincher", 1999, 8.8),
        ]
        for f in sample_films:
         self.add_film(f)


# БЛОК 2

class RecommendationStrategy(ABC):
    def __init__(self, name: str):
        self._name = name
        self._recommendation_count = 5
    @property
    def name(self):
        return self._name
    @name.setter
    def name(self, value: str):
        if not isinstance(value, str):
            raise TypeError("Название стратегии должно быть строкой")
        self._name = value
    @property
    def recommendation_count(self):
        return self._recommendation_count
    @recommendation_count.setter
    def recommendation_count(self, value: int):
        if value < 1:
            raise ValueError("Количество рекомендаций должно быть положительным")
        self._recommendation_count = value
    @abstractmethod
    def __call__(self, data_manager, user, min_rating=0, min_year=0, max_year=2100):
        pass
    def __str__(self):
        return f"Стратегия: {self._name}"
    def __repr__(self):
        return f"{self.__class__.__name__}(name='{self._name}')"
    @abstractmethod
    def get_description(self):
        pass

@dataclass
class RecommendationResult:
    films: List['Film']
    strategy_name: str
    score: Optional[float] = None
    def __str__(self):
        titles = [f.title for f in self.films]
        return f"{self.strategy_name}: {', '.join(titles)}"
    def __len__(self):
        return len(self.films)

class GenreBasedStrategy(RecommendationStrategy):
    def __init__(self):
        super().__init__("По жанрам")
    def __call__(self, data_manager, user, min_rating=0, min_year=0, max_year=2100):
        preferred_genres = user.preferred_genres
        if not preferred_genres:
            return []
        matching_films = []
        for film in data_manager._films.values():
            if any(genre in preferred_genres for genre in film.genres):
                if film not in user.watched_films and film.rating >= min_rating and min_year <= film.year <= max_year:
                    matching_films.append((film, len([g for g in film.genres if g in preferred_genres])))
        matching_films.sort(key=lambda x: (x[1], x[0].rating), reverse=True)
        return [film for film, _ in matching_films[:self.recommendation_count]]
    def get_description(self):
        return "Рекомендует фильмы любимых жанров пользователя"

class RatingBasedStrategy(RecommendationStrategy):
    def __init__(self):
        super().__init__("По популярности")
    def __call__(self, data_manager, user, min_rating=0, min_year=0, max_year=2100):
        unwatched_films = [
            film for film in data_manager._films.values()
            if film not in user.watched_films and film.rating >= min_rating and min_year <= film.year <= max_year
        ]
        unwatched_films.sort(key=lambda f: f.rating, reverse=True)
        return unwatched_films[:self.recommendation_count]
    def get_description(self):
        return "Рекомендует самые популярные непросмотренные фильмы"

class SimilarUsersStrategy(RecommendationStrategy):
    def __init__(self):
        super().__init__("Похожие на ваши лайки")
    def _calculate_similarity(self, user1: 'User', user2: 'User'):
        common_films = set(user1.watched_films.keys()) & set(user2.watched_films.keys())
        if not common_films:
            return 0.0
        ratings_diff = [
            abs(user1.get_rating(film) or 0 - (user2.get_rating(film) or 0))
            for film in common_films
        ]
        return 1.0 / (1.0 + statistics.mean(ratings_diff))
    def __call__(self, data_manager, user, min_rating=0, min_year=0, max_year=2100):
        all_users = [u for u in data_manager._users.values() if u.user_id != user.user_id]
        if not all_users:
            return []
        similarities = [(other_user, self._calculate_similarity(user, other_user))
                       for other_user in all_users if self._calculate_similarity(user, other_user) > 0]
        if not similarities:
            return []
        similarities.sort(key=lambda x: x[1], reverse=True)
        most_similar_user, similarity_score = similarities[0]
        recommendations = [
            film for film, rating in most_similar_user.watched_films.items()
            if film not in user.watched_films and rating >= 8.0 and film.rating >= min_rating and min_year <= film.year <= max_year
        ]
        recommendations.sort(key=lambda f: most_similar_user.get_rating(f) or 0, reverse=True)
        return recommendations[:self.recommendation_count]
    def get_description(self):
        return "Рекомендует фильмы, которые понравились похожим пользователям"

class RecommendationService:
    def __init__(self):
        self._strategies: Dict[str, RecommendationStrategy] = {}
        self._register_strategies()
    def _register_strategies(self):
        self._strategies["genre"] = GenreBasedStrategy()
        self._strategies["rating"] = RatingBasedStrategy()
        self._strategies["similar"] = SimilarUsersStrategy()
    @property
    def available_strategies(self):
        return list(self._strategies.keys())
    def create_recommendation(self, strategy_name: str, data_manager, user, min_rating=0, min_year=0, max_year=2100):
        if strategy_name not in self._strategies:
            raise ValueError(f"Стратегия '{strategy_name}' не найдена. Доступны: {self.available_strategies}")
        strategy = self._strategies[strategy_name]
        films = strategy(data_manager, user, min_rating, min_year, max_year)
        return RecommendationResult(films, strategy.name)
    def get_all_recommendations(self, data_manager, user, min_rating=0, min_year=0, max_year=2100):
        return {
            name: self.create_recommendation(name, data_manager, user, min_rating, min_year, max_year)
            for name in self.available_strategies
        }
    def __getitem__(self, strategy_name: str):
        return self._strategies[strategy_name]
    def __str__(self):
        strategies = "\n".join([f"  - {s}" for s in self.available_strategies])
        return f"Сервис по рекомендациям со стратегиями:\n{strategies}"


# БЛОК 3

class ConsoleInterface:
    def __init__(self):
        self.data_manager = DataManager()
        self.data_manager.load_data()
        self.recommendation_service = RecommendationService()
        self.current_user = None

    def print_sep(self):                #Базовейший разделитель
        print("\n" + "="*60)

    print('\n  @@@@@@@@@@@@@@     @@@@@@@@@@      @@                 @@@                  @@@        @@@@@@@@@@@                @@@@@@@@@@@        @@@@@@@@@@@@@@           @@@@@@@@@@          @@@@@@@@@@       @@@                  @@@     @@@                  @@@                        '
          '\n  @@                     @@          @@                 @@ @@              @@ @@      @@@         @@@              @@        @@       @@                    @@@          @@@     @@@        @@@     @@ @@              @@ @@     @@ @@              @@ @@                        '                 
          '\n  @@                     @@          @@                 @@   @@          @@   @@    @@@            @@@             @@         @@      @@                   @@                   @@            @@    @@   @@          @@   @@     @@   @@          @@   @@                        '
          '\n  @@                     @@          @@                 @@     @@      @@     @@    @@@             @@             @@        @@       @@                  @@                    @@            @@    @@     @@      @@     @@     @@     @@      @@     @@                        '
          '\n  @@                     @@          @@                 @@       @@  @@       @@    @@@                            @@       @@        @@                  @@                    @@            @@    @@       @@  @@       @@     @@       @@  @@       @@                        '
          '\n  @@                     @@          @@                 @@         @@         @@      @@@                          @@@@@@@@@          @@                  @@                    @@            @@    @@         @@         @@     @@         @@         @@                        '
          '\n  @@@@@@@@@@@@@@         @@          @@                 @@                    @@        @@@@@@@@@@                 @@@@               @@@@@@@@@@@@@@      @@                    @@            @@    @@                    @@     @@                    @@                        '
          '\n  @@                     @@          @@                 @@                    @@          @@@@@@@@@@               @@ @@              @@                  @@                    @@            @@    @@                    @@     @@                    @@                        '
          '\n  @@                     @@          @@                 @@                    @@                  @@@              @@  @@             @@                  @@                    @@            @@    @@                    @@     @@                    @@                        '
          '\n  @@                     @@          @@                 @@                    @@                   @@@             @@   @@            @@                  @@                    @@            @@    @@                    @@     @@                    @@                        '
          '\n  @@                     @@          @@                 @@                    @@    @@@@           @@@             @@    @@           @@                   @@                   @@            @@    @@                    @@     @@                    @@                        '
          '\n  @@                     @@          @@                 @@                    @@      @@@        @@@@              @@     @@          @@                    @@@          @@@     @@@        @@@     @@                    @@     @@                    @@                        '
          '\n  @@                 @@@@@@@@@@      @@@@@@@@@@@@@      @@                    @@        @@@@@@@@@@@                @@      @@         @@@@@@@@@@@@@@           @@@@@@@@@@          @@@@@@@@@@       @@                    @@     @@                    @@                        ')








    def print_menu(self):
        self.print_sep()
        print("Рекомендательная система фильмов".center(60))
        self.print_sep()
        if self.current_user:
            print(f"Текущий пользователь: {self.current_user.user_name}")
            print(f"Просмотрено фильмов: {len(self.current_user.watched_films)}")
            print(f"Любимые жанры: {', '.join(self.current_user.get_preferred_genres_names())}")
            self.print_sep()
        print("1. Регистрация нового пользователя")
        print("2. Вход в систему")
        if self.current_user:
            print("3. Просмотр всех фильмов")
            print("4. Оценить фильм")
            print("5. Получить рекомендации")
            print("6. Настроить предпочтения (жанры)")
            print("7. Просмотр моих оценок")
            print("8. Выйти из аккаунта")
        print("0. Выход из программы")


    def run(self):
        while True:
            self.print_menu()
            choice = input("\nВыберите пункт меню: ").strip()
            if choice == "0":
                print("Exit......")
                break
            elif choice == "1":
                self.register_user()
            elif choice == "2":
                self.login()
            elif self.current_user:
                if choice == "3":
                    self.view_all_films()
                elif choice == "4":
                    self.rate_film()
                elif choice == "5":
                    self.get_recommendations()
                elif choice == "6":
                    self.set_preferences()
                elif choice == "7":
                    self.view_my_ratings()
                elif choice == "8":
                    self.current_user = None
                    print("Вы вышли из аккаунта.")
                else:
                    print("Неверный выбор. Попробуйте снова.")
            else:
                print("Неверный выбор. Попробуйте снова.")

    def register_user(self):
        self.print_sep()
        print("Регистрация нового пользователя".center(60))
        self.print_sep()
        user_name = input("Введите имя пользователя: ").strip()
        if not user_name:
            print("Имя пользователя не может быть пустым.")
            return

        if self.data_manager.get_user_by_name(user_name):
            print("Пользователь с таким именем уже существует.")
            return
        new_id = max(self.data_manager._users.keys(), default=0) + 1
        new_user = User(new_id, user_name)
        self.data_manager.add_user(new_user)
        print(f"Пользователь {user_name} успешно зарегистрирован.")
        self.set_preferences_for_user(new_user)

    def set_preferences_for_user(self, user):
        print("Хотите настроить предпочтения по жанрам? (yes/no): ")
        choice = input().strip().lower()
        if choice == 'yes':
            self.set_preferences(user)

    def set_preferences(self, user=None):
        if user is None:
            user = self.current_user
        self.print_sep()
        print("Настройка предпочтений (жанры)".center(60))
        self.print_sep()
        print("Список жанров:")
        genres = list(Genres)
        for i, genre in enumerate(genres, 1):
            print(f"{i}. {genre.value}")
        print("0. Завершить выбор")
        selected_genres = []
        while True:
            try:
                choice = int(input("Выберите номер жанра (0 для завершения): "))
                if choice == 0:
                    break
                if 1 <= choice <= len(genres):
                    selected_genre = genres[choice - 1]
                    if selected_genre not in selected_genres:
                        selected_genres.append(selected_genre)
                        print(f"Жанр {selected_genre.value} добавлен.")
                    else:
                        print("Этот жанр уже выбран.")
                else:
                    print("Неверный номер. Попробуйте снова.")
            except ValueError:
                print("Введите число.")
        user.preferred_genres = selected_genres
        print("Предпочтения обновлены.")

    def login(self):
        self.print_sep()
        print("Вход в систему".center(60))
        self.print_sep()
        user_name = input("Введите имя пользователя: ").strip()
        user = self.data_manager.get_user_by_name(user_name)
        if user:
            self.current_user = user
            print(f"Добро пожаловать, {user_name}!")
        else:
            print("Пользователь не найден.")

    def view_all_films(self):
            self.print_sep()
            print("Все фильмы".center(60))
            self.print_sep()
            films = list(self.data_manager._films.values())
            if not films:
                print("Нет фильмов в базе.")
                return
            # Сортировка (по году)
            films.sort(key=lambda x: x.year, reverse=True)
            for film in films:
                print(film)
                # Проверка на просмотренность
                if film in self.current_user.watched_films:
                    print(f"Ваша оценка: {self.current_user.get_rating(film)}")
                print()

    def rate_film(self):
            self.print_sep()
            print("Оценка фильма".center(60))
            self.print_sep()
            # Ещё неоценённые фильмы
            unwatched_films = [film for film in self.data_manager._films.values() if
                               film not in self.current_user.watched_films]
            if not unwatched_films:
                print("Вы уже оценили все фильмы.")
                return
            print("Фильмы, которые вы еще не оценили:")
            for i, film in enumerate(unwatched_films, 1):
                print(f"{i}. {film.title} ({film.year}) - рейтинг: {film.rating}")
            try:
                choice = int(input("Выберите номер фильма для оценки: "))
                if 1 <= choice <= len(unwatched_films):
                    film = unwatched_films[choice - 1]
                    rating = float(input("Введите вашу оценку (0-10): "))
                    if 0 <= rating <= 10:
                        self.current_user.add_watched_film(film, rating)
                        print(f"Вы оценили фильм '{film.title}' на {rating}.")
                    else:
                        print("Оценка должна быть от 0 до 10.")
                else:
                    print("Неверный номер фильма.")
            except ValueError:
                print("Ошибка ввода. Введите число.")

    def get_recommendations(self):
        self.print_sep()
        print("Получение рекомендаций".center(60))
        self.print_sep()
        try:
            min_rating = float(input("Минимальный рейтинг фильма (0-10, по умолчанию 0): ") or 0)
            min_year = int(input("Минимальный год выпуска (по умолчанию 0): ") or 0)
            max_year = int(input("Максимальный год выпуска (по умолчанию 2100): ") or 2100)
        except ValueError:
            print("Некорректный ввод. Будут использованы значения по умолчанию.")
            min_rating, min_year, max_year = 0, 0, 2100

        print("\nДоступные стратегии:")
        for key, strategy in self.recommendation_service._strategies.items():
            print(f"{key}. {strategy.name} - {strategy.get_description()}")
        strategy_choice = input("Выберите стратегию (genre/rating/similar): ").strip().lower()

        if strategy_choice not in self.recommendation_service.available_strategies:
            print("Неверный выбор стратегии.")
            return
        # ПОЛУЧЕНИЕ RECOMM
        result = self.recommendation_service.create_recommendation(
            strategy_choice, self.data_manager, self.current_user, min_rating, min_year, max_year
        )
        if result.films:
            print(f"\nРекомендации по стратегии '{result.strategy_name}':")
            for i, film in enumerate(result.films, 1):
                print(f"{i}. {film.title} ({film.year}) - рейтинг: {film.rating}")
        else:
            print("К сожалению, по выбранным критериям рекомендаций нет.")

    def view_my_ratings(self):
        self.print_sep()
        print("Мои оценки".center(60))
        self.print_sep()
        watched = self.current_user.watched_films
        if not watched:
            print("Вы еще не оценили ни одного фильма.")
            return
        for film, rating in watched.items():
            print(f"{film.title} ({film.year}) - ваша оценка: {rating}")



if __name__ == "__main__":
    app = ConsoleInterface()
    app.run()
